//----------------------------------------------------------------------------------------------------------------------
// Eye-tracking recalculation script, version 2021-08-05
// To be used on HTC Vive eye-tracking data generated by our custom logger.
//   For the logger, refer to: https://github.com/kim-dotcom/etc/blob/master/EyeFocusTracker.cs
//
// This is to serve as an alternative to BeGaze ET data event detection pipeline
//   For this reference, see BeGaze2.pdf, pp. 334-337.
//
// Accepted data format: userId; logId; timestamp; hour; min; sec; ms;
//                       xpos; ypos; zpos; uMousePos; vMousePos; wMousePos; uGazePos; vGazePos; wGazePos;
//                       EtPositionX; EtPositionY; EtPositionZ; FixatedObjectName
//   This is taken from a CSV-formated file.
//   Time values are needed to determine dwell times
//   User coordinates, user camera rotation and eye-tracking coordinates are to compute eye travel, in degrees.
//   Fixated object name is to determine the object/category fixation/dwell times.
//   Some extra columns may be present (does not matter; can be a newer iteration of the logger).
//
// Usage: set source file and recalculation algorithm parameters, the script will do the rest.
//
// Notes: uGazePos, vGazePos, wGazePos is redundant (not needed).
//        x-y coordinate of user rortation (uMousePos, vMousePos) is interchanged, has to be flipped.
//----------------------------------------------------------------------------------------------------------------------

//includes
import java.util.Arrays; //for array sorting

//algorithm presets
final boolean PREFILTER_FPS = false;
final int PREFILTER_FPS_FROM = 120;
final int PREFILTER_FPS_TO = 60;
final float DWELLTIME_THRESHOLD = 50;   //in milliseconds
final float DWELLJOIN_THRESHOLD = 32; //in milliseconds

String PARTICIPANT_ID = "501";

//scene presets
final boolean PRIORITY_OBJECTS = false;
final String[] PRIORITY_OBJECTS_LIST = new String[] {};

//working variables
File sourceFile;
Table tableSource;
Table tableDictionaryAllowedNames;
Table tableDictionaryJoinNames;
Table tableDictionaryTranslateNames;
Table tableDictionaryTranslateTemp;
Table tableDataloss;
Table tableIntermediary;
Table tableIntermediary2;
Table tableDestination;
Table tableDestination2;
boolean fileInitialized;
float dwellTimeBaseline;

void setup() {
 noLoop(); 
}

void draw() {
  selectInput("Select ET Datasource:", "selectEtFile");  
}

//----------------------------------------------------------------------------------------------------------------------

public void selectEtFile(File selection) {
  if (selection == null) {
    println("Window was closed or the user hit cancel.");
  } else {
    sourceFile = selection;
    fileInitialized = true;
    //ensure the output files are saved as derivates of the selected file
    String[] fileNameSplit = split(sourceFile.getName(), '.');
    PARTICIPANT_ID = fileNameSplit[0];
    println("User selected " + selection.getAbsolutePath());
    //process the file
    recalculateEtData(PREFILTER_FPS, PREFILTER_FPS_FROM, PREFILTER_FPS_TO,
                      DWELLTIME_THRESHOLD, DWELLJOIN_THRESHOLD,
                      PRIORITY_OBJECTS, PRIORITY_OBJECTS_LIST);
  }
}

public void recalculateEtData(boolean toBePrefiltered, int prefilterFrom, int prefilterTo,
                              float fixationThreshold, float joinTreshold,
                              boolean hasPriorityObjects, String[] priorityObjects) {
  println("Step: loading table...");
  tableSource  = loadTable(sourceFile.getName(), "header, csv");
  tableDictionaryAllowedNames = loadTable("dictionary/dictionaryAllowedNames.csv", "header, csv");
  tableDictionaryJoinNames = loadTable("dictionary/dictionaryJoinNames.csv", "header, csv");
  tableDictionaryTranslateNames = loadTable("dictionary/dictionaryTranslateNames.csv", "header, csv");
  tableDictionaryTranslateTemp = new Table();
  tableDataloss = new Table();
  tableIntermediary = new Table();
  tableIntermediary2 = new Table();
  tableDestination = new Table();
  tableDestination2 = new Table();
  
  if (fileInitialized) {
    //sweep through the source table, create the destination table (different format, compatible with BeGaze output) 
    prefilterEtData(tableSource, toBePrefiltered, prefilterFrom, prefilterTo);
    renameEtObjects(tableSource, tableDictionaryJoinNames);
    recomputeEtAngles(tableSource);
    //TODO: filter for spikes
    //TODO: filter for blinks
    computeDwellTimes(tableSource, tableDataloss, tableIntermediary, tableDestination, fixationThreshold, joinTreshold);
    saveTable(tableDataloss, "/data/" + PARTICIPANT_ID + "_0_dataloss.csv");
    saveTable(tableIntermediary, "/data/" + PARTICIPANT_ID + "_1_prefiltered.csv");
    tableIntermediary = joinDwellTimes(tableIntermediary);
    saveTable(tableIntermediary, "/data/" + PARTICIPANT_ID + "_2_processed.csv");
    //computeDwellTargets(tableDestination, hasPriorityObjects, priorityObjects);
    //finally, write the destinatin table to a CSV file, and exit
    //saveTable(tableSource, "/data/edited-source.csv");
    eraseExtraObjectNames(tableDestination, tableDictionaryAllowedNames);
    translateNames(tableDestination, tableDestination2, tableDictionaryTranslateNames);
    saveTable(tableDestination, "/data/" + PARTICIPANT_ID + "_3_aggregated.csv");
    saveTable(tableDestination2, "/data/" + PARTICIPANT_ID + "_3b_aggregated.csv");
    println("Table written.");
  }
}

//----------------------------------------------------------------------------------------------------------------------

public void prefilterEtData(Table table, boolean proceed, int fpsFrom, int fpsTo) {
  if (!proceed) {
    println("Source table will not be prefiltered.");
    return;
  } else {
    println("Step: prefiltering...");
    int thisTableRows = table.getRowCount();
    int rowsKept = 0;
    int rowsSwept = 1;
    for(int i=1; i < thisTableRows; i++) {
      if ((rowsKept / rowsSwept) >= (fpsTo / fpsFrom)) {
        table.removeRow(i);
        thisTableRows = table.getRowCount(); //to move the pointer up across the reduced table
      } else {
        rowsKept++;        
      }
      rowsSwept++;
    }
  }
}

public void renameEtObjects(Table table, Table dictionary) {
  int thisTableRows = table.getRowCount();
  String thisObjectName = "";
  String thisObjectRename = "";
  for(int i = 0; i < thisTableRows; i++) {
    thisObjectName = table.getRow(i).getString("FixatedObjectName");
    TableRow needle = dictionary.findRow(thisObjectName, "translateFrom");
    if (needle != null) {
      thisObjectRename = needle.getString("translateTo");
      table.getRow(i).setString("FixatedObjectName", thisObjectRename);
    }
    thisObjectName = "";
    thisObjectRename = "";
  }  
}

public void recomputeEtAngles(Table table) {
  println("Step: recomputing angles...");
  int thisTableRows = table.getRowCount();
  PVector cameraPosition;
  PVector cameraRotation;
  PVector gazePosition;
  PVector gazeRotation;
  PVector gazeRotationPrevious = null;
  table.addColumn("gazeCameraDistance", Table.FLOAT);
  table.addColumn("gazeMovementDistance", Table.FLOAT);
  table.addColumn("gazeMovementSpeed", Table.FLOAT);
  table.addColumn("gazeMovementAcceleration", Table.FLOAT);
  table.addColumn("gazeMovementType", Table.FLOAT);
  for(int i=1; i < thisTableRows; i++) {
    //existing data: these three are taken directly from the log
    cameraPosition = new PVector(table.getRow(i).getFloat("xpos"),
                                 table.getRow(i).getFloat("ypos"),
                                 table.getRow(i).getFloat("zpos"));
    cameraRotation = new PVector(table.getRow(i).getFloat("uMousePos"),   //x-y coordinates are switched here ??
                                 table.getRow(i).getFloat("vMousePos"),   //x-y coordinates are switched here ??
                                 table.getRow(i).getFloat("wMousePos"));
    gazePosition = new PVector(table.getRow(i).getFloat("EtPositionX"),
                               table.getRow(i).getFloat("EtPositionY"),
                               table.getRow(i).getFloat("EtPositionZ"));
    //existing data: this last one is not in the log - has to be recomputed
    gazeRotation = (gazePosition.sub(cameraPosition)).normalize();
    
    //camera rotation is logged in wrong format (degrees instead of normalized vector)
    //thus, to be coverted, eulerAngles to radians
    float cameraElevation = radians(cameraRotation.x);
    float cameraHeading = radians(cameraRotation.y);
    PVector cameraRotationRadians = new PVector(cos(cameraElevation) * sin(cameraHeading),
                                                sin(cameraElevation),
                                                cos(cameraElevation) * cos(cameraHeading));
                                                
    //compute camera-gaze angle difference
    float gazeCameraDistance = degrees(PVector.angleBetween(gazeRotation, cameraRotationRadians));
    float gazeMovementDistance = 0;
    
    //compute gaze difference from previous frame
    table.setFloat(i, "gazeCameraDistance", gazeCameraDistance);
    if (i > 1) {
      gazeMovementDistance = degrees(PVector.angleBetween(gazeRotation, gazeRotationPrevious));      
    }
    table.setFloat(i, "gazeMovementDistance", gazeMovementDistance);
    gazeRotationPrevious = gazeRotation;
    
    //compute degree speed, acceleration (degrees in second)
    float timeSegmentFrom = table.getRow(i-1).getFloat("ms");
    float timeSegmentTo = table.getRow(i).getFloat("ms");
    if (i > 1 && (timeSegmentTo != timeSegmentFrom)) { //case of dulpicated log at the same time, i.e. no movement
      if (timeSegmentTo < timeSegmentFrom) { //over 1000ms
        timeSegmentTo += 1000;
      }
      float gazeSpeed = gazeMovementDistance * (1000 / (timeSegmentTo - timeSegmentFrom));
      table.setFloat(i, "gazeMovementSpeed", gazeSpeed);
    } else {
      table.setFloat(i, "gazeMovementSpeed", 0);
    }
    
    //TODO: compute velocity skewness
    
    //TODO: flag junk data
  }
}

public void computeDwellTimes(Table source, Table dataloss, Table intermediary, Table destination,
                              float fixationThreshold, float joinTreshold) {
  println("Step: dwell times...");
  int thisTableRows = source.getRowCount();
  //compute dataloss
  dataloss.addColumn("participantId", Table.STRING);
  dataloss.addColumn("datalossType", Table.STRING);
  dataloss.addColumn("datalossStart", Table.FLOAT);
  dataloss.addColumn("datalossEnd", Table.FLOAT);
  dataloss.addColumn("datalossTime", Table.FLOAT);
  dataloss.addColumn("datalossSegmentPercentile", Table.FLOAT);
  dataloss.addColumn("datalossPercentage", Table.FLOAT);
  float totalTime = getRowTime(source,thisTableRows-1) - getRowTime(source,0);
  float totalDatalossTime = 0;
  float datalossBaselineTime = getRowTime(source,0);
  float currentDatalossTime = 0;
  float currentDatalossSweepStart = 0;
  float currentDatalossSweepEnd = 0;
  boolean currentDatalossSweepActive = false;
  //sweep through the source table for dataloss rows, to log
  for(int i=1; i < thisTableRows; i++) {
    if (source.getRow(i).getString("FixatedObjectName").equals("no user")) {
      if (!currentDatalossSweepActive) {
        currentDatalossSweepStart = getRowTime(source,i);
        currentDatalossSweepActive = true;
      }
    } else {
      if (currentDatalossSweepActive) {
        currentDatalossSweepEnd = getRowTime(source,i);
        currentDatalossTime = currentDatalossSweepEnd - currentDatalossSweepStart;
        totalDatalossTime += currentDatalossTime;
        currentDatalossSweepActive = false;
        TableRow newRow1 = dataloss.addRow();
        newRow1.setString("participantId", PARTICIPANT_ID);
        newRow1.setString("datalossType", "single");
        newRow1.setFloat("datalossStart", (currentDatalossSweepStart - datalossBaselineTime)/1000);
        newRow1.setFloat("datalossEnd", (currentDatalossSweepEnd - datalossBaselineTime)/1000);
        newRow1.setFloat("datalossTime", currentDatalossTime/1000);
        newRow1.setFloat("datalossSegmentPercentile", ((currentDatalossSweepStart - datalossBaselineTime)
                                                    /totalTime)*100);
        newRow1.setFloat("datalossPercentage", (currentDatalossTime/totalTime)*100);        
      }
    }
  }
  //last dataloss row (summary) to log
  TableRow newRow2 = dataloss.addRow();
  newRow2.setString("participantId", PARTICIPANT_ID);
  newRow2.setString("datalossType", "total");
  newRow2.setFloat("datalossStart", -1);
  newRow2.setFloat("datalossEnd", -1);
  newRow2.setFloat("datalossTime", totalDatalossTime/1000);
  newRow2.setFloat("datalossSegmentPercentile", -1);
  newRow2.setFloat("datalossPercentage", (totalDatalossTime/totalTime)*100);  
  //throw away dataloss rows
  for(int i=1; i < thisTableRows; i++) {
    if (source.getRow(i).getString("FixatedObjectName").equals("no user")) {
      source.removeRow(i);
      i--; // so as not to jump over every 2nd in a row
      thisTableRows = source.getRowCount();
    }
  }
  
  //set the intermediary table format
  intermediary.addColumn("participantId", Table.STRING);
  intermediary.addColumn("objectName", Table.STRING);
  intermediary.addColumn("objectDwellFirstTime", Table.FLOAT);
  intermediary.addColumn("objectDwellEndTime", Table.FLOAT);
  intermediary.addColumn("objectDwellTotalTime", Table.FLOAT);
  intermediary.addColumn("objectDwellValid", Table.INT);
  intermediary.addColumn("objectDwellPosX", Table.FLOAT);
  intermediary.addColumn("objectDwellPosY", Table.FLOAT);
  intermediary.addColumn("objectDwellPosZ", Table.FLOAT);
  intermediary.addColumn("objectDwellDistance", Table.FLOAT);
  
  //set the destinatin table format
  destination.addColumn("participantId", Table.STRING);
  destination.addColumn("objectName", Table.STRING);
  destination.addColumn("objectDwellFirstTime", Table.FLOAT);
  destination.addColumn("objectDwellTotalTime", Table.FLOAT);
  destination.addColumn("objectDwellCount", Table.INT);
  
  //log intermediary table
  String currentObject = source.getRow(0).getString("FixatedObjectName");
  dwellTimeBaseline = getRowTime(source, 0);
  int rowFrom = 0;
  int rowTo = 0;
  for(int i=1; i < thisTableRows; i++) {
    if (source.getRow(i).getString("FixatedObjectName").equals(currentObject)) {
      rowTo++;
    } else {
      logToIntermediaryTable(tableSource, tableIntermediary, rowFrom, rowTo);
      currentObject = source.getRow(i).getString("FixatedObjectName");
      rowFrom = i;
      rowTo = i;
    }
  }
  
  //verify dwell times (old)
  String currentObjectPointer = source.getRow(1).getString("FixatedObjectName");
  int currentObjectRow = 1;
  int currentObjectRowCount = 0;
  float currentObjectDwellStart = getRowTime(source, 1);  
  for(int i=2; i < thisTableRows; i++) {
    //if object dwell does not continue...
    if (!source.getRow(i).getString("FixatedObjectName").equals(currentObjectPointer)) {
      float currentObjectDwellEnd = getRowTime(source, i-1);
      //... get this dwell's time and see if it is considered a fixation
      float currentDwellTime = currentObjectDwellEnd - currentObjectDwellStart;
      //logToIntermediaryTable(tableSource, tableIntermediary, currentObjectRow, i);
      if (currentDwellTime > fixationThreshold) {
        
        //keep these rows, write to destination Table
        int foundEntryAt = -1;
        for(int j=0; j < destination.getRowCount(); j++) {
          if (destination.getRow(j).getString("objectName").equals(currentObjectPointer)) {
            foundEntryAt = j;
          }
        }
        //TODO: instead of this, put it into an intermediary table and sweep that one later on
        //TODO: calculate edges of dwell times from unfiltered table (greedy alg., extend by fixation time until false)
        //  Possibly join multiple dwell events here
        if (foundEntryAt == -1) {
          TableRow newRow3 = destination.addRow();
          newRow3.setString("participantId", PARTICIPANT_ID);
          newRow3.setString("objectName", currentObjectPointer);
          newRow3.setFloat("objectDwellFirstTime", currentObjectDwellStart - dwellTimeBaseline);
          newRow3.setFloat("objectDwellTotalTime", currentDwellTime);
          newRow3.setInt("objectDwellCount", 1);
        } else {
          destination.setFloat(foundEntryAt, "objectDwellTotalTime",
                               destination.getRow(foundEntryAt).getFloat("objectDwellTotalTime") + currentDwellTime);
          destination.setInt(foundEntryAt, "objectDwellCount",
                             destination.getRow(foundEntryAt).getInt("objectDwellCount") + 1);
        }
      } else {
        //remove these rows
        for(int j=0; j <= currentObjectRowCount; j++) {
          source.removeRow(currentObjectRow);
        }
        i = i - (currentObjectRowCount + 1);
        thisTableRows = source.getRowCount();
      }      
      
      //... and start over with new object in focus
      currentObjectDwellStart = getRowTime(source, i);
      currentObjectPointer = source.getRow(i).getString("FixatedObjectName");
      currentObjectRow = i;
      currentObjectRowCount = 0;
    } else {
      currentObjectRowCount++;
    }
  }
}

public Table joinDwellTimes(Table sourceTable) {
  Table tempTable = new Table();
  tempTable = sourceTable;
  int thisTableRows = tempTable.getRowCount();
  int tablePointerRow = 0;
  String tablePointerName = sourceTable.getRow(0).getString("objectName");
  //first pass - remove nonvalid non-equals
  for (int i = 1; i < thisTableRows; i++) {
    if (tempTable.getRow(i).getInt("objectDwellValid") != 1) {
      if (!tempTable.getRow(i).getString("objectName").equals(tablePointerName)) {
        tempTable.removeRow(i);
        i--;
        thisTableRows = tempTable.getRowCount();
      }
    } else {
      tablePointerName = tempTable.getRow(i).getString("objectName");
      tablePointerRow = i;
    }
  }
  //second pass - join equals
  tablePointerRow = 0;
  tablePointerName = tempTable.getRow(0).getString("objectName");
  thisTableRows = tempTable.getRowCount(); println();
  for (int i = 0; i < thisTableRows-1; i++) {
    if (tempTable.getRow(i).getString("objectName").equals(tempTable.getRow(i+1).getString("objectName"))) {
      if ((tempTable.getRow(i+1).getFloat("objectDwellFirstTime") -
           tempTable.getRow(i).getFloat("objectDwellEndTime")) < DWELLJOIN_THRESHOLD) {
        //join them
        tempTable.setFloat(i, "objectDwellTotalTime",
                           tempTable.getRow(i+1).getFloat("objectDwellEndTime") -
                           tempTable.getRow(i).getFloat("objectDwellFirstTime"));
        tempTable.setFloat(i, "objectDwellEndTime", tempTable.getRow(i+1).getFloat("objectDwellEndTime"));
        tempTable.removeRow(i+1);
        i--;
        thisTableRows = tempTable.getRowCount();
      } else {
        //do nothing
      }
    }
  }
  //third pass - remove remaining crap
  thisTableRows = tempTable.getRowCount();
  for (int i = 0; i < thisTableRows; i++) {
    if (tempTable.getRow(i).getInt("objectDwellValid") != 1) {
      tempTable.removeRow(i);
      i--;
      thisTableRows = tempTable.getRowCount();
    }
  }
    
  return tempTable;
}

public void computeDwellTargets(Table destination, boolean proceed, String[] objects) {
  if (!proceed) {
    println("No priority objects to consider.");
    return;
  } else {
    println("Step: dwell targets...");
    //... 
  }
}


public float getRowTime(Table table, int row) {
  return table.getRow(row).getFloat("hour")*3600*1000 + table.getRow(row).getFloat("min")*60*1000 +
         table.getRow(row).getFloat("sec")*1000 + table.getRow(row).getFloat("ms");
}

public void logToIntermediaryTable(Table sourceTable, Table intermediaryTable, int idFrom, int idTo) {
  float timeFrom = getRowTime(sourceTable, idFrom);
  float timeTo = getRowTime(sourceTable, idTo);
  TableRow newRow = intermediaryTable.addRow();
  //user/object names
  newRow.setString("participantId", PARTICIPANT_ID);
  newRow.setString("objectName", sourceTable.getRow(idFrom).getString("FixatedObjectName"));
  //dwell times
  newRow.setFloat("objectDwellFirstTime", timeFrom - dwellTimeBaseline);
  newRow.setFloat("objectDwellEndTime", timeTo - dwellTimeBaseline);
  newRow.setFloat("objectDwellTotalTime", timeTo - timeFrom);
  if ((timeTo - timeFrom) < DWELLTIME_THRESHOLD) {
    newRow.setInt("objectDwellValid", 0);
  } else {
    newRow.setInt("objectDwellValid", 1);
  }
  //position vectors and distance
  float xpos = sourceTable.getRow(idFrom).getFloat("xpos");
  float ypos = sourceTable.getRow(idFrom).getFloat("ypos");
  float zpos = sourceTable.getRow(idFrom).getFloat("zpos");
  newRow.setFloat("objectDwellPosX", xpos);
  newRow.setFloat("objectDwellPosY", ypos);
  newRow.setFloat("objectDwellPosZ", zpos);
  PVector distanceFrom = new PVector(xpos, ypos, zpos);
  PVector distanceTo = new PVector(sourceTable.getRow(idFrom).getFloat("EtPositionX"),
                                   sourceTable.getRow(idFrom).getFloat("EtPositionY"),
                                   sourceTable.getRow(idFrom).getFloat("EtPositionZ"));
  float distance = PVector.dist(distanceFrom, distanceTo);
  newRow.setFloat("objectDwellDistance", distance);
}

public void eraseExtraObjectNames(Table table, Table dictionary) {
  int thisTableRows = table.getRowCount();
  String thisObjectName = "";
  for(int i = 0; i < thisTableRows; i++) {
    thisObjectName = table.getRow(i).getString("objectName");
    TableRow needle = dictionary.findRow(thisObjectName, "allowedObjectNames");
    if (needle == null) {
      table.removeRow(i);
      thisTableRows--;
      i--;
    }
    thisObjectName = "";
  }  
}

public void translateNames (Table outputSource, Table outputTranslated, Table dictionary) {
  //set the destinatin table format
  outputTranslated.addColumn("participantId", Table.STRING); //participantId
  outputTranslated.addColumn("AoiId", Table.INT); //new one...
  outputTranslated.addColumn("AreaOfInterest", Table.STRING);    //objectName
  outputTranslated.addColumn("EntryTime", Table.FLOAT); //objectDwellFirstTime
  outputTranslated.addColumn("DwellTime", Table.FLOAT); //objectDwellTotalTime
  outputTranslated.addColumn("Revisits", Table.INT); //objectDwellCount
  //first do the translation
  String thisObjectName = "";  
  for (int i = 0; i < outputSource.getRowCount(); i++) {
    TableRow newRow = outputTranslated.addRow();
    newRow.setString("participantId", outputSource.getRow(i).getString("participantId"));
    newRow.setFloat("EntryTime", outputSource.getRow(i).getFloat("objectDwellFirstTime"));
    newRow.setFloat("DwellTime", outputSource.getRow(i).getFloat("objectDwellTotalTime"));
    newRow.setInt("Revisits", outputSource.getRow(i).getInt("objectDwellCount") - 1);
    thisObjectName = outputSource.getRow(i).getString("objectName");
    TableRow needle = dictionary.findRow(thisObjectName, "translateFrom");
    if (needle != null) {
      newRow.setInt("AoiId", needle.getInt("translateId"));
      newRow.setString("AreaOfInterest", needle.getString("translateTo"));
    } else {
      newRow.setInt("AoiId", 999);
      newRow.setString("AreaOfInterest", outputSource.getRow(i).getString("objectName"));
    }
  }
  //then add the missing entries
  int thisObjectId = 999;
  for (int i = 0; i < dictionary.getRowCount(); i++) {
    thisObjectName = dictionary.getRow(i).getString("translateTo");
    thisObjectId = dictionary.getRow(i).getInt("translateId");
    TableRow needle = outputTranslated.findRow(thisObjectName, "AreaOfInterest");
    if (needle == null) {
      TableRow newRow = outputTranslated.addRow();
      newRow.setString("participantId", outputTranslated.getRow(1).getString("participantId"));
      newRow.setFloat("EntryTime", 0);
      newRow.setFloat("DwellTime", 0);
      newRow.setInt("Revisits", 0);
      newRow.setInt("AoiId", thisObjectId);
      newRow.setString("AreaOfInterest", thisObjectName);
    }
  }
}
